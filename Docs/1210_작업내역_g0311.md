# 2025-12-10 작업 내역 (g0311)

작성일: 2025-12-11
작성자: g0311

## 작업 개요
| 시간 | 커밋 | 내용 |
|------|------|------|
| 12/10 18:31 | bca919c | Ragdoll 처리 개선 |
| 12/10 23:43 | 65a2349 | 점프 킥 스킬 구현 |
| 12/11 00:06 | fbfcb7f | 노티파이 뷰어 기능 강화 |
| 12/11 01:27 | 1f563e8 | 몽타주 PlayRate 시스템 구현 |

---

## 1. Ragdoll 처리 개선 (bca919c)

### 변경 사항
- `SetCollisionEnabled()` 함수를 `UPrimitiveComponent`와 `USkeletalMeshComponent`에 추가
- Ragdoll 활성화 시 collision 상태를 `PhysicsOnly`로 변경하여 물리 시뮬레이션만 수행

### 코드 스니펫

**PrimitiveComponent.cpp - SetCollisionEnabled 구현:**
```cpp
void UPrimitiveComponent::SetCollisionEnabled(ECollisionState NewState)
{
    bOverrideCollisionSetting = true;
    CollisionEnabled = NewState;

    if (BodyInstance && BodyInstance->RigidActor)
    {
        UWorld* World = GetWorld();
        if (!World || !World->GetPhysScene())
            return;

        PxScene* PxScenePtr = World->GetPhysScene()->GetScene();
        if (!PxScenePtr)
            return;

        SCOPED_PHYSX_WRITE_LOCK(*PxScenePtr);

        PxRigidActor* Actor = BodyInstance->RigidActor;
        PxU32 NumShapes = Actor->getNbShapes();
        std::vector<PxShape*> Shapes(NumShapes);
        Actor->getShapes(Shapes.data(), NumShapes);

        for (PxShape* Shape : Shapes)
        {
            if (!Shape) continue;

            switch (NewState)
            {
                case ECollisionState::NoCollision:
                    Shape->setFlag(PxShapeFlag::eTRIGGER_SHAPE, false);
                    Shape->setFlag(PxShapeFlag::eSIMULATION_SHAPE, false);
                    Shape->setFlag(PxShapeFlag::eSCENE_QUERY_SHAPE, false);
                    break;
                case ECollisionState::PhysicsOnly:
                    Shape->setFlag(PxShapeFlag::eTRIGGER_SHAPE, false);
                    Shape->setFlag(PxShapeFlag::eSIMULATION_SHAPE, true);
                    Shape->setFlag(PxShapeFlag::eSCENE_QUERY_SHAPE, false);
                    break;
                // ... (QueryOnly, QueryAndPhysics)
            }
        }
    }
}
```

**AngryCoachCharacter.cpp - Die() 함수 수정:**
```cpp
void AAngryCoachCharacter::Die()
{
    // 먼저 AttackShape 비활성화...

    // Ragdoll 활성화 및 Collision 설정
    if (SkeletalMeshComp)
    {
        SkeletalMeshComp->SetRagDollEnabled(true);
        SkeletalMeshComp->SetCollisionEnabled(ECollisionState::PhysicsOnly);
    }

    // 사운드 재생...
}
```

---

## 2. 점프 킥 스킬 구현 (65a2349)

### 변경 사항
- `UDefaultJumpAttackSkill` 클래스 생성
- 점프 중 공격 입력 시 점프 킥 발동
- `OnLanded()` 콜백으로 착지 시 공격 상태 정리
- 고릴라 악세서리는 점프 공격 비활성화 (`nullptr` 스킬 등록)

### 코드 스니펫

**DefaultJumpAttackSkill.h:**
```cpp
UCLASS()
class UDefaultJumpAttackSkill : public USkillBase
{
public:
    GENERATED_REFLECTION_BODY()

    UDefaultJumpAttackSkill();
    virtual void Activate(AActor* Caster) override;

protected:
    float LaunchSpeed = 8.0f;    // 돌진 속도 (XY 방향)
    float LaunchZSpeed = -3.0f;  // 수직 속도 (아래로)
};
```

**DefaultJumpAttackSkill.cpp - Activate 구현:**
```cpp
void UDefaultJumpAttackSkill::Activate(AActor* Caster)
{
    AAngryCoachCharacter* Character = Cast<AAngryCoachCharacter>(Caster);
    if (!Character) return;

    // 몽타주 재생
    if (Montage)
        Character->PlayMontage(Montage);

    // 입력 방향으로 캐릭터 회전
    FVector Direction = Character->GetJumpAttackDirection();
    if (Direction.IsZero())
    {
        FVector Euler = Character->GetActorRotation().ToEulerZYXDeg();
        float Yaw = Euler.Z * (PI / 180.0f);
        Direction = FVector(std::cos(Yaw), std::sin(Yaw), 0.0f);
    }

    float TargetYaw = std::atan2(Direction.Y, Direction.X) * (180.0f / PI);
    FQuat TargetRotation = FQuat::MakeFromEulerZYX(FVector(0.0f, 0.0f, TargetYaw));
    Character->SetActorRotation(TargetRotation);

    // 돌진 (XY 방향 + 아래로)
    FVector LaunchVelocity = Direction * LaunchSpeed;
    LaunchVelocity.Z = LaunchZSpeed;

    if (UCharacterMovementComponent* Movement = Character->GetCharacterMovement())
    {
        Movement->SetVelocity(FVector::Zero());
        Movement->LaunchCharacter(LaunchVelocity, true, true);
    }
}
```

**AngryCoachPlayerController.cpp - 점프 중 공격 처리:**
```cpp
// 점프 중 공격 → 점프 공격
if (Player1->GetCurrentState() == ECharacterState::Jumping)
{
    if (bIsTKeyDown || bIsYKeyDown)
    {
        FVector InputDir = FVector::Zero();
        if (InputManager.IsKeyDown('W')) InputDir.X += 1.0f;
        if (InputManager.IsKeyDown('S')) InputDir.X -= 1.0f;
        if (InputManager.IsKeyDown('D')) InputDir.Y += 1.0f;
        if (InputManager.IsKeyDown('A')) InputDir.Y -= 1.0f;

        Player1->OnJumpAttackInput(InputDir);
        return;
    }
    return;  // 점프 중엔 일반 공격 처리 안함
}
```

**SkillComponent.cpp - 스킬 오버라이드 개선:**
```cpp
void USkillComponent::OverrideSkills(const TMap<ESkillSlot, USkillBase*>& NewSkill, AAccessoryActor* InAccessory)
{
    CurrentAccessory = InAccessory;
    ActiveSkills.Empty();

    // 1. 기본 스킬 먼저 등록 (점프 공격 등)
    BuildSkillInstances(DefualtSkill, nullptr);

    // 2. 악세서리 스킬로 덮어쓰기 (nullptr이면 해당 슬롯 제거)
    for (const auto& Pair : NewSkill)
    {
        ESkillSlot Slot = Pair.first;
        USkillBase* Skill = Pair.second;

        if (Skill)
        {
            Skill->SetSourceAccessory(InAccessory);
            ActiveSkills.Add(Slot, Skill);
        }
        else
        {
            // nullptr이면 해당 슬롯 제거 (고릴라 점프 공격 비활성화용)
            ActiveSkills.Remove(Slot);
        }
    }
}
```

---

## 3. 노티파이 뷰어 기능 강화 (fbfcb7f)

### 변경 사항
- `AnimNotify_ParticleStart`에 `SocketName`, `ParticleSystemPath` 프로퍼티 추가
- 노티파이 타입별 색상 구분 (사운드: 파랑, 함수: 노랑, 파티클 시작: 초록, 파티클 종료: 빨강)
- `CallFunction`, `ParticleStart`, `ParticleEnd` 노티파이 편집 UI 추가
- 노티파이 메타 데이터 직렬화 지원

### 코드 스니펫

**AnimNotify_ParticleStart.h:**
```cpp
class UAnimNotify_ParticleStart : public UAnimNotify
{
public:
    virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation) override;

    // 파티클을 붙일 소켓 이름 (비어있으면 루트)
    FName SocketName;

    // 파티클 시스템 경로
    FString ParticleSystemPath;
};
```

**AnimSequenceBase.cpp - 메타 데이터 저장/로드:**
```cpp
// SaveMeta
else if (Evt.Notify && Evt.Notify->IsA<UAnimNotify_ParticleStart>())
{
    const UAnimNotify_ParticleStart* PStart = static_cast<const UAnimNotify_ParticleStart*>(Evt.Notify);
    Data["SocketName"] = PStart->SocketName.ToString().c_str();
    Data["ParticleSystemPath"] = PStart->ParticleSystemPath.c_str();
}

// LoadMeta
else if (ClassStr == "UAnimNotify_ParticleStart" || ClassStr == "ParticleStart")
{
    UAnimNotify_ParticleStart* PStart = NewObject<UAnimNotify_ParticleStart>();
    if (PStart && DataPtr)
    {
        if (DataPtr->hasKey("SocketName"))
            PStart->SocketName = FName(DataPtr->at("SocketName").ToString());
        if (DataPtr->hasKey("ParticleSystemPath"))
            PStart->ParticleSystemPath = DataPtr->at("ParticleSystemPath").ToString();
    }
    Evt.Notify = PStart;
}
```

**SSkeletalMeshViewerWindow.cpp - 노티파이 색상 구분:**
```cpp
// 노티파이 타입별 색상 지정
ImU32 FillCol, LineCol;
FString Label = Notify.NotifyName.ToString();

if (Notify.Notify && Notify.Notify->IsA<UAnimNotify_PlaySound>())
{
    // 사운드: 파란색
    FillCol = IM_COL32(80, 120, 220, bHover ? 180 : 140);
    LineCol = IM_COL32(120, 160, 255, 200);
}
else if (Notify.Notify && Notify.Notify->IsA<UAnimNotify_CallFunction>())
{
    // 함수 호출: 노란색
    FillCol = IM_COL32(200, 180, 60, bHover ? 180 : 140);
    LineCol = IM_COL32(240, 220, 100, 200);
}
else if (Notify.Notify && Notify.Notify->IsA<UAnimNotify_ParticleStart>())
{
    // 파티클 시작: 초록색
    FillCol = IM_COL32(60, 180, 80, bHover ? 180 : 140);
    LineCol = IM_COL32(100, 220, 120, 200);
}
else if (Notify.Notify && Notify.Notify->IsA<UAnimNotify_ParticleEnd>())
{
    // 파티클 종료: 빨간색
    FillCol = IM_COL32(180, 60, 60, bHover ? 180 : 140);
    LineCol = IM_COL32(220, 100, 100, 200);
}
```

---

## 4. 몽타주 PlayRate 시스템 구현 (1f563e8)

### 변경 사항
- `UAnimMontage`에 전체 `PlayRate` 프로퍼티 추가
- 섹션별 PlayRate와 전역 PlayRate 곱연산 적용
- 스켈레탈 뷰어에 재생 속도 슬라이더 UI 추가 (0.1x ~ 3.0x)
- 몽타주 PlayRate JSON 직렬화 지원

### 코드 스니펫

**AnimMontage.h:**
```cpp
/** 전체 재생 속도 (기본 1.0) */
float PlayRate = 1.0f;
```

**AnimInstance.cpp - PlayMontage 수정:**
```cpp
float UAnimInstance::PlayMontage(UAnimMontage* Montage, float PlayRate)
{
    // ...
    MontageState->PlayRate = PlayRate * Montage->PlayRate;  // 몽타주 자체 PlayRate 적용
    // ...
    float Duration = Montage->GetPlayLength() / MontageState->PlayRate;
    // ...
}
```

**AnimInstance.cpp - 노티파이 트리거 수정:**
```cpp
void UAnimInstance::TriggerMontageNotifies(float DeltaSeconds)
{
    // 섹션별 재생 속도 적용
    float SectionPlayRate = 1.0f;
    if (Montage->HasSections() && MontageState->CurrentSectionIndex < Montage->GetNumSections())
    {
        SectionPlayRate = Montage->Sections[MontageState->CurrentSectionIndex].PlayRate;
    }

    float DeltaMove = DeltaSeconds * MontageState->PlayRate * SectionPlayRate;
    // ...
}
```

**SSkeletalMeshViewerWindow.cpp - 재생 속도 UI:**
```cpp
// 재생 속도 슬라이더
ImGui::SetNextItemWidth(100.0f);
if (ImGui::SliderFloat("##Speed", &State->PlaybackSpeed, 0.1f, 3.0f, "x%.1f"))
{
    State->PlaybackSpeed = ImClamp(State->PlaybackSpeed, 0.1f, 3.0f);
}
if (ImGui::IsItemHovered())
{
    ImGui::SetTooltip("Playback Speed");
}
ImGui::SameLine();
if (ImGui::Button("1x"))
{
    State->PlaybackSpeed = 1.0f;
}
```

**SSkeletalMeshViewerWindow.cpp - 몽타주 PlayRate 편집:**
```cpp
// 전체 재생 속도
ImGui::DragFloat("Play Rate", &ActiveMontage->PlayRate, 0.05f, 0.1f, 3.0f, "x%.2f");
if (ImGui::IsItemHovered())
{
    ImGui::SetTooltip("Montage playback speed (saved to file)");
}
```

---

## 기타 수정 사항

### 스킬 사운드 (1771923)
- 각 악세서리 스페셜 스킬에 사운드 재생 로직 추가 (`CloakSpecialAttackSkill`, `GorillaSpecialAttackSkill`, `KnifeSpecialAttackSkill`, `PunchSpecialAttackSkill`)

### CharacterMovementComponent (92d087c)
- `JumpZVelocity` 기본값 변경: `4.0` → `6.0f`
- `Gravity` 프로퍼티 UPROPERTY 노출

### 기타 버그 수정
- `dea47e8`: StaticMeshComponent collision init null check
- `afd25d1`: Socket write back 수정
- `e03989e`: Shape attach transform 수정
- `ba7bfad`: Accessory change handle 수정
